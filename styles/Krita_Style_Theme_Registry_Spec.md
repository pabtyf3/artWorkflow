# Krita Style / Theme Registry — Refined Specification

## Purpose

The **Krita Style / Theme Registry** defines how visual style is constrained, shared, and applied
within the **Krita workspace** generated by artWorkflow.

It exists to:
- promote visual consistency
- reduce cognitive load for non-artists
- support solo developers
- remain fully editable by human artists

It does **not** generate art, enforce aesthetics, or make creative decisions.

---

## Scope

This specification applies **only** to Krita interpreters (dry-run and real execution).

Other interpreters:
- may ignore style themes entirely
- or treat them as metadata only

Style themes must never affect:
- scene layout
- asset placement
- geometry
- scale
- camera decisions

---

## Design Principles

### 1. Workspace, Not Outcome
Themes configure **tools and constraints**, not finished visuals.

### 2. Deterministic Resolution
Given the same theme identifier and version, the same resources are resolved.

### 3. Opt-In and Overrideable
Themes are optional and can be overridden at the scene level.

### 4. Shareable and Portable
Themes are data-driven and intended to be reused across projects.

---

## Theme Registry Structure

Themes are defined as **static data**, not executable code.

Recommended structure:

```
styles/
 └─ themes/
     └─ storybook_painterly/
         ├─ theme.json
         ├─ README.md
         └─ resources/
             ├─ brushes/
             ├─ palettes/
             └─ textures/
```

---

## Theme Definition: `theme.json`

### Required Metadata

```json
{
  "id": "storybook_painterly",
  "name": "Storybook Painterly",
  "version": "1.0.0",
  "description": "Soft, illustrative, painterly style for narrative scenes.",
  "target": "krita"
}
```

Rules:
- `id` must be globally unique
- `version` must be semver
- `target` must be `"krita"`

---

## Tool Availability

Defines what tools are made available to the artist.

```json
{
  "tools": {
    "brush_presets": ["soft_round", "dry_brush", "chalk"],
    "erasers": ["soft_eraser"],
    "blending_modes": ["normal", "multiply", "overlay"]
  }
}
```

Rules:
- Tools are **made available**, not auto-selected
- Absence implies no restriction
- Interpreters must not fail if a tool is missing

---

## Colour & Value Guidance

Defines **ranges and tendencies**, not exact values.

```json
{
  "colour_guidance": {
    "palette": "storybook_warm",
    "value_range": "mid",
    "contrast": "low_to_medium",
    "saturation": "moderate"
  }
}
```

These are **annotations**, not enforcement rules.

---

## Texture & Surface Guidance

```json
{
  "texture_guidance": {
    "allowed": ["paper_grain", "canvas_soft"],
    "usage_notes": "Textures should remain subtle and secondary."
  }
}
```

Textures must:
- never be auto-applied
- never override painted detail

---

## Layer & Workflow Hints

Optional hints for workspace organisation.

```json
{
  "workflow_hints": {
    "preferred_layers": ["Background", "Midground", "Foreground", "Lighting"],
    "separate_lighting": true,
    "notes": "Encourage paint-over lighting flexibility."
  }
}
```

These hints must:
- not override interpreter responsibilities
- not reposition assets
- not add or remove layers unilaterally

---

## Restrictions (Optional)

Explicit exclusions to preserve consistency.

```json
{
  "restrictions": {
    "disallowed_tools": ["hard_round", "photo_textures"],
    "notes": "Avoid sharp or photographic elements."
  }
}
```

Restrictions must be:
- explicit
- conservative
- non-fatal if violated (emit warnings)

---

## Scene-Level Overrides

Scenes may provide overrides:

```json
"style": {
  "theme": "storybook_painterly",
  "overrides": {
    "colour_guidance.saturation": "low"
  }
}
```

Rules:
- Overrides are shallow (dot-path based)
- Invalid overrides are ignored with warnings
- Overrides may reduce, but never expand, capabilities

---

## Validation & Versioning

- Themes should be schema-validated
- Version changes must be explicit
- Breaking changes require a new major version

If a theme:
- is missing
- is invalid
- targets a different interpreter

The Krita interpreter must:
- fall back to neutral defaults
- emit a warning
- continue safely

---

## Interpreter Responsibilities (Krita)

The Krita interpreter MAY:
- load theme metadata
- make tools available
- annotate workspace plans
- organise resource panels

The Krita interpreter MUST NOT:
- auto-paint
- auto-select brushes
- enforce colour choices
- generate textures
- override human decisions

---

## Dry-Run Behaviour

In dry-run mode:
- themes are resolved symbolically
- loaded resources are listed by name
- no external files are touched

Dry-run output must clearly show:
- which theme was selected
- which resources would be made available
- which overrides were applied or ignored

---

## Summary

The Krita Style / Theme Registry exists to answer:

> **“What stylistic tools and guidance are available for this scene?”**

Not:
- “What should this look like?”
- “How should it be painted?”

If a theme starts making creative decisions, it is out of scope.
